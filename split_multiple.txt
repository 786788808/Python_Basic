import unittest
import os
import tempfile
import shutil
import json
import pandas as pd
import logging
from datetime import datetime
from unittest.mock import patch, MagicMock

# 设置测试环境
class TestHKExSuspension(unittest.TestCase):
    def setUp(self):
        # 创建临时目录
        self.test_dir = tempfile.mkdtemp()
        
        # 创建模拟配置文件
        self.create_mock_config_files()
        
        # 设置日志
        logging.basicConfig(level=logging.DEBUG)
        self.logger = logging.getLogger()
    
    def tearDown(self):
        # 清理临时目录
        shutil.rmtree(self.test_dir, ignore_errors=True)
    
    def create_mock_config_files(self):
        """创建模拟的JSON配置文件"""
        # env.json
        env_data = {
            "gcp_env": {
                "proxy": "https://proxy.example.com"
            }
        }
        with open(os.path.join(self.test_dir, 'env.json'), 'w') as f:
            json.dump(env_data, f)
        
        # webS_HKExSuspension.json
        param_data = {
            "file_dir": "/data/files",
            "log_dir": "/var/logs",
            "file_url": "https://api.example.com/data"
        }
        with open(os.path.join(self.test_dir, 'webS_HKExSuspension.json'), 'w') as f:
            json.dump(param_data, f)

    # 测试日期范围函数
    @patch('calendar.monthrange')
    def test_define_data_start_end_date_daily(self, mock_monthrange):
        """测试daily模式的日期范围生成"""
        mock_monthrange.return_value = (0, 31)  # 模拟31天的月份
        
        # 假设的原始函数（需要根据实际代码调整）
        def define_data_start_end_date(loading_type, order_date):
            if loading_type == 'daily':
                date_obj = datetime.strptime(order_date, '%Y%m%d')
                from_date = date_obj.replace(day=1).strftime('%Y%m%d')
                _, last_day = calendar.monthrange(date_obj.year, date_obj.month)
                to_date = date_obj.replace(day=last_day).strftime('%Y%m%d')
                return [[from_date, to_date]]
        
        result = define_data_start_end_date('daily', '20230115')
        self.assertEqual(result, [['20230101', '20230131']])
    
    @patch('calendar.monthrange')
    def test_define_data_start_end_date_initial_load(self, mock_monthrange):
        """测试initial_load模式的日期范围生成"""
        mock_monthrange.side_effect = [(0, 30), (0, 31)]  # 模拟两个月份
        
        # 假设的原始函数（需要根据实际代码调整）
        def define_data_start_end_date(loading_type, order_date):
            if loading_type == 'initial_load':
                initial_load_start_date = datetime.strptime('19990401', '%Y%m%d')
                final_date = datetime.strptime(order_date, '%Y%m%d')
                
                from_to_date = []
                while initial_load_start_date <= final_date:
                    month_start_date = initial_load_start_date.replace(day=1).strftime('%Y%m%d')
                    _, last_day = calendar.monthrange(initial_load_start_date.year, initial_load_start_date.month)
                    month_end_date = initial_load_start_date.replace(day=last_day).strftime('%Y%m%d')
                    from_to_date.append([month_start_date, month_end_date])
                    
                    next_month_date = initial_load_start_date + timedelta(days=32)
                    initial_load_start_date = next_month_date.replace(day=1)
                return from_to_date
        
        result = define_data_start_end_date('initial_load', '19990615')
        expected = [
            ['19990401', '19990430'],
            ['19990501', '19990531'],
            ['19990601', '19990630']
        ]
        self.assertEqual(result, expected)

    # 测试配置类
    @patch('os.makedirs')
    @patch('datetime.datetime')
    def test_HKExSuspConfig_init(self, mock_datetime, mock_makedirs):
        """测试配置类初始化"""
        # 模拟当前时间
        mock_now = datetime(2023, 6, 15, 12, 30, 45)
        mock_datetime.now.return_value = mock_now
        mock_datetime.strptime.side_effect = lambda *args, **kw: datetime.strptime(*args, **kw)
        
        # 模拟的类定义（基于图片内容）
        class HKExSuspConfig:
            def __init__(self, gcp_env, order_date, from_date, to_date):
                self.file_date = datetime.strptime(from_date, '%Y%m%d').strftime('%Y%m%d')
                self.file_dir_date = None
                self.document_types = None
                self.html_filename = None
                self.html_paths = None
                self.csv_filename = None
                self.csv_paths = None
                self.susp_status_list = None
                self.txcode = None
                self.proxies = None
                self.headers = None
                self.url_prefix = None
                self.init_config(gcp_env, order_date, from_date, to_date)
            
            def init_config(self, gcp_env, order_date, from_date, to_date):
                with open('env.json', encoding='utf-8') as f:
                    env = json.load(f)
                with open('webS_HKExSuspension.json', encoding='utf-8') as f:
                    param = json.load(f)
                
                file_dir = param.get('file_dir')
                timestamp = datetime.now().strftime('%H%M%S')
                from_date_str = from_date + '.' + timestamp
                self.file_dir_date = os.path.join(file_dir, order_date, from_date_str)
                os.makedirs(self.file_dir_date, exist_ok=True)
                
                self.document_types = ["Trading Halt", "Suspension", "Resumption"]
                self.txcode = ['17560', '17550', '17650']
                self.susp_status_list = ["r", "s", "R"]
                self.html_filename = [
                    f"TradingHalt_{from_date}.html",
                    f"Suspension_{from_date}.html",
                    f"Resumption_{from_date}.html"
                ]
                self.csv_filename = [
                    f"TradingHalt_{from_date}.csv",
                    f"Suspension_{from_date}.csv",
                    f"Resumption_{from_date}.csv"
                ]
                self.html_paths = [os.path.join(self.file_dir_date, f) for f in self.html_filename]
                self.csv_paths = [os.path.join(self.file_dir_date, f) for f in self.csv_filename]
                
                proxy = env.get(gcp_env, {}).get("proxy")
                self.proxies = {"https": proxy} if proxy else {}
                
                self.headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36'}
                self.url_prefix = param.get('file_url')
                
                log_dir = param.get("log_dir")
                print(log_dir)
        
        # 在临时目录中运行
        with patch('os.getcwd', return_value=self.test_dir):
            config = HKExSuspConfig(
                "gcp_env",
                "20230701",
                "20230601",
                "20230630"
            )
        
        # 验证配置
        self.assertEqual(config.file_date, "20230601")
        self.assertEqual(config.document_types, ["Trading Halt", "Suspension", "Resumption"])
        self.assertEqual(config.txcode, ['17560', '17550', '17650'])
        self.assertEqual(config.susp_status_list, ["r", "s", "R"])
        self.assertEqual(config.proxies, {"https": "https://proxy.example.com"})
        self.assertEqual(config.url_prefix, "https://api.example.com/data")
        
        # 验证文件路径
        expected_dir = os.path.join(
            "/data/files",
            "20230701",
            "20230601.123045"
        )
        self.assertEqual(config.file_dir_date, expected_dir)
        
        # 验证文件名
        self.assertEqual(config.html_filename, [
            "TradingHalt_20230601.html",
            "Suspension_20230601.html",
            "Resumption_20230601.html"
        ])
        self.assertEqual(config.csv_filename, [
            "TradingHalt_20230601.csv",
            "Suspension_20230601.csv",
            "Resumption_20230601.csv"
        ])
        
        # 验证目录创建
        mock_makedirs.assert_called_once_with(expected_dir, exist_ok=True)

    # 测试数据处理函数
    def test_split_multiple_stock_stockname(self):
        """测试股票代码和名称拆分逻辑"""
        # 模拟的原始函数（基于图片内容）
        def split_multiple_stock_stockname(df):
            expanded_rows = []
            for _, row in df.iterrows():
                stock_code = str(row['Stock_code']) if pd.notna(row['Stock_code']) else ''
                stock_name = str(row['Short_stock_name']) if pd.notna(row['Short_stock_name']) else ''
                
                # 空值跳过
                if not stock_code or not stock_name or stock_code.lower() == 'null' or stock_name.lower() == 'null':
                    continue
                
                codes = [c.strip() for c in stock_code.split('+++')]
                names = [n.strip() for n in stock_name.split('+++')]
                
                # 情况1: 单代码单名称
                if len(codes) == 1 and len(names) == 1:
                    expanded_rows.append(row)
                
                # 情况2: 多代码单名称
                elif len(codes) > 1 and len(names) == 1:
                    for code in codes:
                        new_row = row.copy()
                        new_row['Stock_code'] = code
                        new_row['Short_stock_name'] = names[0]
                        expanded_rows.append(new_row)
                
                # 情况3: 单代码多名称
                elif len(codes) == 1 and len(names) > 1:
                    for name in names:
                        new_row = row.copy()
                        new_row['Stock_code'] = codes[0]
                        new_row['Short_stock_name'] = name
                        expanded_rows.append(new_row)
                
                # 情况4: 多代码多名称
                elif len(codes) > 1 and len(names) > 1:
                    min_len = min(len(codes), len(names))
                    for i in range(min_len):
                        new_row = row.copy()
                        new_row['Stock_code'] = codes[i]
                        new_row['Short_stock_name'] = names[i]
                        expanded_rows.append(new_row)
            
            return pd.DataFrame(expanded_rows)
        
        # 创建测试数据
        data = {
            'Stock_code': ['A+++B', 'C', 'D+++E+++F', 'G'],
            'Short_stock_name': ['Name1', 'Name2+++Name3', 'Name4', 'Name5+++Name6'],
            'Other_Column': [1, 2, 3, 4]
        }
        df = pd.DataFrame(data)
        
        # 处理数据
        result = split_multiple_stock_stockname(df)
        
        # 验证结果
        self.assertEqual(len(result), 7)
        self.assertEqual(list(result['Stock_code']), ['A', 'B', 'C', 'C', 'D', 'E', 'G'])
        self.assertEqual(list(result['Short_stock_name']), ['Name1', 'Name1', 'Name2', 'Name3', 'Name4', 'Name4', 'Name5'])

    # 测试HTML解析函数
    @patch('lxml.etree.HTML')
    def test_parse_file(self, mock_html):
        """测试HTML解析逻辑"""
        # 模拟的原始函数（基于图片内容）
        def parse_file(config, from_date, to_date):
            for i in range(len(config.html_filename)):
                with open(config.html_paths[i], 'r', encoding='utf-8') as file:
                    html_content = file.read()
                
                tree = etree.HTML(html_content)
                data_list = tree.xpath('//tbody')
                
                # 这里简化了解析逻辑，实际测试中需要完整模拟
                release_time = []
                stock_code = []
                short_stock_name = []
                
                # 返回模拟数据
                return pd.DataFrame({
                    'Release_time': release_time,
                    'Stock_code': stock_code,
                    'Short_stock_name': short_stock_name
                })
        
        # 创建模拟配置
        class MockConfig:
            html_filename = ['file1.html', 'file2.html']
            html_paths = ['/path/to/file1.html', '/path/to/file2.html']
        
        # 模拟文件读取
        with patch('builtins.open', unittest.mock.mock_open(read_data='<html></html>')):
            # 模拟lxml解析
            mock_tree = MagicMock()
            mock_html.return_value = mock_tree
            mock_tree.xpath.return_value = []
            
            # 调用函数
            result = parse_file(MockConfig(), '20230101', '20230131')
            
            # 验证结果
            self.assertIsInstance(result, pd.DataFrame)
            self.assertEqual(len(result), 0)

if __name__ == '__main__':
    unittest.main()
